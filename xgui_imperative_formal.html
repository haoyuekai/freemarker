<!doctype html>
<html lang="en" class="page-type-section">
<head prefix="og: http://ogp.me/ns#">
<meta charset="utf-8">
<title>具体细节 - FreeMarker 手册</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="format-detection" content="telephone=no">
<meta property="og:site_name" content="FreeMarker 手册">
<meta property="og:title" content="具体细节">
<meta property="og:locale" content="en_US">
<meta property="og:url" content="http://freemarker.org/docs/xgui_imperative_formal.html">
<link rel="canoical" href="http://freemarker.org/docs/xgui_imperative_formal.html">
<link rel="icon" href="favicon.png" type="image/png">
<link rel="stylesheet" type="text/css" href="docgen-resources/docgen.min.css">
</head>
<body itemscope itemtype="https://schema.org/Code">
    <meta itemprop="url" content="http://freemarker.org/docs/">
    <meta itemprop="name" content="FreeMarker 手册">

  <!--[if lte IE 9]>
  <div style="background-color: #C00; color: #fff; padding: 12px 24px;">Please use a modern browser to view this website.</div>
  <![endif]--><div class="header-top-bg"><div class="site-width header-top"><a class="logo" href="http://freemarker.org" role="banner">            <img itemprop="image" src="logo.png" alt="FreeMarker">
</a><ul class="tabs"><li><a href="http://freemarker.org/">Home</a></li><li class="current"><a href="index.html">Manual</a></li><li><a class="external" href="http://freemarker.org/docs/api/index.html">Java API</a></li></ul><ul class="secondary-tabs"><li><a class="tab icon-heart" href="http://freemarker.org/contribute.html" title="Contribute"><span>Contribute</span></a></li><li><a class="tab icon-bug" href="https://sourceforge.net/p/freemarker/bugs/new/" title="Report a Bug"><span>Report a Bug</span></a></li><li><a class="tab icon-download" href="http://freemarker.org/freemarkerdownload.html" title="Download"><span>Download</span></a></li></ul></div></div><div class="header-bottom-bg"><div class="site-width search-row"><a href="toc.html" class="navigation-header">Manual</a><div class="navigation-header"></div></div><div class="site-width breadcrumb-row"><ul class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList"><li class="step-0" itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem"><a class="label" itemprop="item" href="toc.html"><span itemprop="name">FreeMarker 手册</span></a></li><li class="step-1" itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem"><a class="label" itemprop="item" href="xgui.html"><span itemprop="name">XML处理指南</span></a></li><li class="step-2" itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem"><a class="label" itemprop="item" href="xgui_imperative.html"><span itemprop="name">必要的XML处理</span></a></li><li class="step-3" itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem"><a class="label" itemprop="item" href="xgui_imperative_formal.html"><span itemprop="name">具体细节</span></a></li></ul><div class="bookmarks" title="Bookmarks"><span class="sr-only">Bookmarks:</span><ul class="bookmark-list"><li><a href="alphaidx.html">Alpha. index</a></li><li><a href="gloss.html">Glossary</a></li><li><a href="dgui_template_exp.html#exp_cheatsheet">Expressions</a></li><li><a href="ref_builtins_alphaidx.html">?builtins</a></li><li><a href="ref_directive_alphaidx.html">#directives</a></li><li><a href="ref_specvar.html">.spec_vars</a></li><li><a href="app_faq.html">FAQ</a></li></ul></div></div></div>    <div class="main-content site-width">
      <div class="content-wrapper">
  <div id="table-of-contents-wrapper" class="col-left">
      <script>var breadcrumb = ["FreeMarker 手册","XML处理指南","必要的XML处理","具体细节"];</script>
      <script src="toc.js"></script>
      <script src="docgen-resources/main.min.js"></script>
  </div>
<div class="col-right"><div class="page-content"><div class="page-title"><div class="pagers top"><a class="paging-arrow previous" href="xgui_imperative_learn.html"><span>Previous</span></a><a class="paging-arrow next" href="xgui_declarative.html"><span>Next</span></a></div><div class="title-wrapper">
<h1 class="content-header header-section1" id="xgui_imperative_formal" itemprop="headline">具体细节</h1>
</div></div><p>每一个和DOM树中单独结点对应的变量都是结点和哈希表类型的多类型的变量
		(对于程序员：实现<code class="inline-code">TemplateNodeModel</code> 
		和 <code class="inline-code">TemplateHashModel</code> 两个接口)。因此，你可以使用<a href="ref_builtins_node.html">结点内建函数</a>来处理它们。
		哈希表的键被解释为XPath表达式，除了在下面表格中显示的特殊键。
		一些结点变量也有字符串类型，所以你可以使用它们作为字符串变量
		(对于程序员：他们需要实现 <code class="inline-code">TemplateScalarModel</code> 接口)。</p><a name="misc.xguiTable"></a>  <div class="table-responsive">
    <table class="table">

          <thead>
            <tr>
              <th>结点类型 (<code class="inline-code">?node_type</code>)</th>


              <th>结点名称 (<code class="inline-code">?node_name</code>)</th>


              <th>字符串值 (比如 <code class="inline-code">&lt;p&gt;${node}</code>)</th>


              <th>特殊哈希表键</th>

            </tr>

          </thead>


          <tbody>
            <tr>
              <td><code class="inline-code">&quot;document&quot;</code></td>


              <td><code class="inline-code">&quot;@document&quot;</code></td>


              <td>没有字符串值。(当你尝试用字符串来使用时发生错误。)</td>


              <td><code class="inline-code">&quot;<em class="code-color">elementName</em>&quot;</code>,
              <code class="inline-code">&quot;<em class="code-color">prefix</em>:<em class="code-color">elementName</em>&quot;</code>,
              <code class="inline-code">&quot;*&quot;</code>, <code class="inline-code">&quot;**&quot;</code>,
              <code class="inline-code">&quot;@@markup&quot;</code>,
              <code class="inline-code">&quot;@@nested_markup&quot;</code>,
              <code class="inline-code">&quot;@@text&quot;</code></td>

            </tr>


            <tr>
              <td><code class="inline-code">&quot;element&quot;</code></td>


              <td><code class="inline-code">&quot;<em class="code-color">name</em>&quot;</code>：
			  元素的名称。这是本地命名(也就是没有命名空间前缀的名字)。</td>


              <td>如果它没有子元素，所有子结点的文本串联起来。
			  当你尝试用它当字符串时会发生错误。</td>


              <td><code class="inline-code">&quot;<em class="code-color">elementName</em>&quot;</code>,
              <code class="inline-code">&quot;<em class="code-color">prefix</em>:<em class="code-color">elementName</em>&quot;</code>,
              <code class="inline-code">&quot;*&quot;</code>, <code class="inline-code">&quot;**&quot;</code>,
              <code class="inline-code">&quot;@<em class="code-color">attrName</em>&quot;</code>,
              <code class="inline-code">&quot;@<em class="code-color">prefix</em>:<em class="code-color">attrName</em>&quot;</code>,
              <code class="inline-code">&quot;@@&quot;</code>, <code class="inline-code">&quot;@*&quot;</code>,
              <code class="inline-code">&quot;@@start_tag&quot;</code>,
              <code class="inline-code">&quot;@@end_tag&quot;</code>,
              <code class="inline-code">&quot;@@attributes_markup&quot;</code>,
              <code class="inline-code">&quot;@@markup&quot;</code>,
              <code class="inline-code">&quot;@@nested_markup&quot;</code>,
              <code class="inline-code">&quot;@@text&quot;</code>, <code class="inline-code">&quot;@@qname&quot;</code></td>

            </tr>


            <tr>
              <td><code class="inline-code">&quot;text&quot;</code></td>


              <td><code class="inline-code">&quot;@text&quot;</code></td>


              <td>文本本身。</td>


              <td><code class="inline-code">&quot;@@markup&quot;</code>,
              <code class="inline-code">&quot;@@nested_markup&quot;</code>,
              <code class="inline-code">&quot;@@text&quot;</code></td>

            </tr>


            <tr>
              <td><code class="inline-code">&quot;pi&quot;</code></td>


              <td><code class="inline-code">&quot;@pi$<em class="code-color">target</em>&quot;</code></td>


              <td>在目标名称和 <code class="inline-code">?&gt;</code> 之间的部分。</td>


              <td><code class="inline-code">&quot;@@markup&quot;</code>,
              <code class="inline-code">&quot;@@nested_markup&quot;</code>,
              <code class="inline-code">&quot;@@text&quot;</code></td>

            </tr>


            <tr>
              <td><code class="inline-code">&quot;comment&quot;</code></td>


              <td><code class="inline-code">&quot;@comment&quot;</code></td>


              <td>注释的文本，不包括分隔符 <code class="inline-code">&lt;!--</code> 
			  和 <code class="inline-code">--&gt;</code>。</td>


              <td><code class="inline-code">&quot;@@markup&quot;</code>,
              <code class="inline-code">&quot;@@nested_markup&quot;</code>,
              <code class="inline-code">&quot;@@text&quot;</code></td>

            </tr>


            <tr>
              <td><code class="inline-code">&quot;attribute&quot;</code></td>


              <td><code class="inline-code">&quot;<em class="code-color">name</em>&quot;</code>：
			  属性的名字。这是本地命名(也就是没有命名空间前缀的名字)。</td>


              <td>属性的值。</td>


              <td><code class="inline-code">&quot;@@markup&quot;</code>,
              <code class="inline-code">&quot;@@nested_markup&quot;</code>,
              <code class="inline-code">&quot;@@text&quot;</code>, <code class="inline-code">&quot;@@qname&quot;</code></td>

            </tr>


            <tr>
              <td><code class="inline-code">&quot;document_type&quot;</code></td>


              <td><code class="inline-code">&quot;@document_type$<em class="code-color">name</em>&quot;</code>:
              <code class="inline-code"><em class="code-color">name</em></code> 是文档元素的名字。</td>


              <td>没有字符串值。(当你尝试用字符串来使用时发生错误。)</td>


              <td><code class="inline-code">&quot;@@markup&quot;</code>,
              <code class="inline-code">&quot;@@nested_markup&quot;</code>,
              <code class="inline-code">&quot;@@text&quot;</code></td>

            </tr>

          </tbody>

            </table>
  </div>
<p>注意：</p><ul>
          <li>
            <p>没有CDATA类型，CDATA结点被透明地认为是文本结点。</p>
          </li>

          <li>
            <p>变量 <em>不</em> 支持 <code class="inline-code">?keys</code> 
			和 <code class="inline-code">?values</code>。</p>
          </li>

          <li>
            <p>元素和属性结点的名字是本地命名，也就是，它们不包含命名空间前缀。
			结点所属的命名空间的URI可以使用内建函数 <code class="inline-code">?node_namespace</code> 
			来获得。</p>
          </li>

          <li>
            <p>XPath表达式需要Jaxen(推荐使用，但是请使用1.1-beta-8之后的版本；
			<a href="http://jaxen.org/">可以从此处下载</a>)
			或者Apache的Xalan库，否则会有错误并且终止模板的执行。要注意，
			隐藏在XPath表达式中一些特殊哈希表键有相同的意思，
			尽管没有XPath可用的实现，但那些XPath表达式仍然会起作用。
			<span class="marked-for-programmers">如果Xalan和Jaxen两者都可用，
			FreeMarker 将会使用Xalen，除非你在Java代码中通过调用 
			<code class="inline-code">freemarker.ext.dom.NodeModel.useJaxenXPathSupport()</code> 
			方法，才会使用Jaxen。</span></p>
          </li>

          <li>
            <p>如果Jaxen被用来支持XPath(而不是Xalan)，
			那么 FreeMarker 变量通过XPath变量的引用是可见的
			(比如<code class="inline-code">doc[&quot;book/chapter[title=$currentTitle]&quot;]</code>)。</p>
          </li>
        </ul><p>特殊哈希表键的含义：</p><ul>
          <li>
            <p><code class="inline-code">&quot;<em class="code-color">elementName</em>&quot;</code>，
            <code class="inline-code">&quot;<em class="code-color">prefix</em>:<em class="code-color">elementName</em>&quot;</code>：
			返回元素名为 <code class="inline-code"><em class="code-color">elementName</em></code> 
			的子结点的序列。(注意这里的&quot;子&quot;结点就是 <em>直接</em> 后继)
			选择是XML命名空间的标识，除非XML文档用不再命名空间标识结点中的XML解析器解析。
			在XML命名空间标识结点中，不含前缀的名字(<em>elementName</em>)
			仅仅选择不属于任何XML命名空间的元素(除非你已经注册了默认的XML命名空间)，
			有前缀的名字(<em>prefix</em>:<em>elementName</em>)
			选择属于前缀代表命名空间的元素。前缀的注册和默认XML命名空间的设置是由<a href="ref_directive_ftl.html#ref.directive.ftl"><code>ftl</code>
            指令</a> 的 <code class="inline-code">ns_prefixes</code> 参数完成的。</p>
          </li>

          <li>
            <p><code class="inline-code">&quot;*&quot;</code>：返回所有子(直接后继) 
			<em>元素</em> 结点的序列。这个序列会按&quot;文档顺序&quot;包含元素，
			也就是说，按照每个XML结点的表现形式的第一个字符的顺序出现
			(在一般实体的扩展之后)。</p>
          </li>

          <li>
            <p><code class="inline-code">&quot;**&quot;</code>：返回所有后继 <em>元素</em> 
			结点的序列。这个序列按文档顺序包含元素。</p>
          </li>

          <li>
            <p><code class="inline-code">&quot;@<em class="code-color">attName</em>&quot;</code>，
            <code class="inline-code">&quot;@<em class="code-color">prefix</em>:<em class="code-color">attrName</em>&quot;</code>：
			作为一个大小为1，包含属性结点的序列的形式，返回元素的属性名 
			<code class="inline-code"><em class="code-color">attName</em></code>，如果属性不存在时，
			作为一个空序列返回(所以来检查属性是否存在，可以使用
			<code class="inline-code">foo.@<em class="code-color">attName</em>[0]??</code>，
			<em>而不是</em> 
			<code class="inline-code">foo.@<em class="code-color">attName</em>??</code>)。
			正如 <code class="inline-code">&quot;<em class="code-color">elementName</em>&quot;</code> 这个特殊的键，
			如果序列的长度为1，那么它也当作是第一个子变量。如果没有使用 
			<code class="inline-code"><em class="code-color">prefix</em></code>，那么它只返回属性，
			而不使用XML命名空间(尽管你已经设置了默认的XML命名空间)。
			如果使用了 <code class="inline-code"><em class="code-color">prefix</em></code>，
			它返回仅仅属于关联的 <code class="inline-code"><em class="code-color">prefix</em></code> 
			的XML命名空间的属性。前缀的注册是由 <a href="ref_directive_ftl.html#ref.directive.ftl"><code>ftl</code>
            指令</a> 的 <code class="inline-code">ns_prefixes</code> 参数完成的。</p>
          </li>

          <li>
            <p><code class="inline-code">&quot;@@&quot;</code> 或 <code class="inline-code">&quot;@*&quot;</code>
			：返回属于父结点的结点的属性序列，这和XPath中的 
			<code class="inline-code">@*</code> 是相同。</p>
          </li>

          <li>
            <p><code class="inline-code">&quot;@@qname&quot;</code>：返回元素的完全限定名
			(比如 <code class="inline-code">e:book</code>，和由 <code class="inline-code">?node_name</code> 
			返回的本地名 <code class="inline-code">book</code> 形成对比)。使用的前缀
			(如 <code class="inline-code">e</code>)是基于在当前命名空间用 <code class="inline-code">ftl</code> 
			指令的 <code class="inline-code">ns_prefixes</code> 参数注册的前缀而选择的，
			而不受源XML文档中使用的前缀影响。如果你已经设置了一个默认的XML命名空间，
			那么结点会使用默认的，前缀 <code class="inline-code">D</code> 就会被使用了。
			不属于任何XML命名空间的结点，不使用前缀(尽管你设置过默认的命名空间)。
			如果结点没有为命名空间注册的前缀，那结果是不存在的变量
			(<code class="inline-code">node.@@qname??</code> 是 <code class="inline-code">false</code>)。</p>
          </li>

          <li>
            <p><code class="inline-code">&quot;@@markup&quot;</code>：这会以字符串形式返回一个结点的完整XML标记。
			(完整的XML标记表示它也包含子结点的标记，而且包含子结点的子结点的标记，以此类推)
			你得到的标记和在源XML文档中的标记相比不是必须的，它只是语义上的相同。特别地，
			注意CDATA段将会解释成普通文本。也要注意基于你是怎么用包装原生的XML文档的，
			注释或处理指令结点可能被移除，而且它们将会从源文件的输出中消失。
			对于在输出XML段的每个XML命名空间，第一个被输出的开始标记将会包含 
			<code class="inline-code">xmlns:<em class="code-color">prefix</em></code> 属性，
			而且那些前缀将会在输出的元素和属性名中使用。这些前缀和使用 <code class="inline-code">ftl</code> 
			指令的 <code class="inline-code">ns_prefixes</code> 参数注册的前缀相同
			(没有前缀使用 <code class="inline-code">D</code>，因为它会和 <code class="inline-code">xmlns</code> 
			属性被用来注册默认的命名空间)，如果XML命名空间没有定义前缀，
			那么会使用一个任意未被选择使用的前缀。</p>
          </li>

          <li>
            <p><code class="inline-code">&quot;@@nested_markup&quot;</code>：这个和 <code class="inline-code">&quot;@@markup&quot;</code> 
			相似，但是它返回不包括开放和封闭标记元素的XML标记。对于文档结点，它返回和 
			<code class="inline-code">&quot;@@markup&quot;</code> 相同的内容。对于其他类型结点(文本，处理指令等)，
			它返回一个空字符串。不像 <code class="inline-code">&quot;@@markup&quot;</code>，在输出中没有 
			<code class="inline-code">xmlns:<em class="code-color">prefix</em></code> 属性，
			但是关于在元素和属性名中使用前缀规则是相同的。</p>
          </li>

          <li>
            <p><code class="inline-code">&quot;@@text&quot;</code>：它返回文本结点(所有后继文本结点，
			而不是直接子结点)点的值，连接成一个单独的字符串。
			如果结点没有子文本结点，那么返回的是空字符串。</p>
          </li>

          <li>
            <p><code class="inline-code">&quot;@@start_tag&quot;</code>：返回元素结点 <a href="gloss.html#gloss.startTag">开始标签</a> 的标记。
			正如 <code class="inline-code">@@markup</code>，输出和源XML文档相比不是必须的，
			但是在语义上是相同的。关于XML命名空间
			(输出中的<code class="inline-code">xmlns:<em class="code-color">prefix</em></code>属性等)，
			规则和 <code class="inline-code">&quot;@@markup&quot;</code> 是相同的。</p>
          </li>

          <li>
            <p><code class="inline-code">&quot;@@end_tag&quot;</code>：返回元素结点 <a href="gloss.html#gloss.endTag">结束标签</a> 的标记，正如 
			<code class="inline-code">@@markup</code>，输出和源XML文档相比不是必须的，
			但是在语义上是相同的。</p>
          </li>

          <li>
            <p><code class="inline-code">@@attributes_markup</code>：返回元素结点 <a href="gloss.html#gloss.attribute">属性</a> 的标记，正如 
			<code class="inline-code">@@markup</code>，输出和源XML文档相比不是必须的，
			但是在语义上是相同的。</p>
          </li>
        </ul>
          



<h2 class="content-header header-section2" id="autoid_138">结点序列</h2>


          <p>许多特殊哈希表的键(指的是上面所有的列表)，
		  和XPath表达式的结果是结点集(参考<a href="http://www.w3.org/TR/xpath">XPath 推荐</a>)，
		  返回结点的序列。</p>

          <p>这些结点序列，如果它们只存储一个子变量，也会当作子变量本身。
		  例如，如果 <code class="inline-code">book</code> 元素只有一个 <code class="inline-code">title</code> 
		  子结点，<code class="inline-code">${book.title[0]}</code> 和 <code class="inline-code">${book.title}</code> 
		  是相同的。</p>

          <p>返回一个空结点序列是普通的情形。例如，如果一个确定的XML文档，
		  <code class="inline-code">book</code> 元素没有子元素 <code class="inline-code">chapter</code>，
		  那么 <code class="inline-code">book.chapter</code> 的结果就是一个空的结点序列。
		  要小心！这也意味着 <code class="inline-code">book.chaptre</code>(注意打字错误)
		  也会返回空的结点序列，而且会抛出错误而停止执行。同时，
		  <code class="inline-code">book.chaptre??</code>(注意打字错误)将会返回 
		  <code class="inline-code">true</code>，因为空的序列存在，所以你不得不使用
		  <code class="inline-code">book.chaptre[0]??</code> 来检查。</p>

          <p>结点序列存储的不是1个结点(但是0或者比1多的结点)
		  也会支持上面所描述的哈希表的键。那就是，下面这些特殊的键都是支持的：</p>

          <ul>
            <li>
              <p><code class="inline-code">&quot;<em class="code-color">elementName</em>&quot;</code>,
              <code class="inline-code">&quot;<em class="code-color">prefix</em>:<em class="code-color">elementName</em>&quot;</code></p>
            </li>

            <li>
              <p><code class="inline-code">&quot;@<em class="code-color">attrName</em>&quot;</code>,
              <code class="inline-code">&quot;@<em class="code-color">prefix</em>:<em class="code-color">attrName</em>&quot;</code></p>
            </li>

            <li>
              <p><code class="inline-code">&quot;@@markup&quot;</code>,
              <code class="inline-code">&quot;@@nested_markup&quot;</code></p>
            </li>

            <li>
              <p><code class="inline-code">&quot;@@text&quot;</code></p>
            </li>

            <li>
              <p><code class="inline-code">&quot;*&quot;</code>, <code class="inline-code">&quot;**&quot;</code></p>
            </li>

            <li>
              <p><code class="inline-code">&quot;@@&quot;</code>, <code class="inline-code">&quot;@*&quot;</code></p>
            </li>
          </ul>

          <p>当在一个包含多于1个结点或0个结点序列里应用上面这些特殊的键中之一的时候，
		  那么对于序列(就是特殊的键可以起作用，比如文本结点对于键 <code class="inline-code">*</code> 
		  或 <code class="inline-code">@foo</code> 将会被略过)中的每个结点，
		  这些特殊的键将会被应用于单独的结点，结果将会从最终的结果中被连接。
		  结果会被以和结点在序列中出现的对应顺序来连接。
		  连接就意味着字符串或序列的连接是基于结果类型之上的。
		  如果特殊的键会得到单独结点的字符串结果，那么对于多个结点的结果就是一个单独的字符串
		  (对单独结点的结果进行连接)，而如果特殊的键返回单独结点的序列，那么对于多个结点，
		  结果就是一个单独的序列。如果在你应用特殊键的序列中没有结点，那么字符串结果就是空串，
		  而序列结果就是空序列。</p>

          <p>XPath表达式可以和结点序列一同使用。然而，对于0或者大于1的结点，
		  因为Xalan对XPath实现的限制，仅仅你使用Jaxen代替Xalan时它才会起作用。</p>
        <div class="bottom-pagers-wrapper"><div class="pagers bottom"><a class="paging-arrow previous" href="xgui_imperative_learn.html"><span>Previous</span></a><a class="paging-arrow next" href="xgui_declarative.html"><span>Next</span></a></div></div></div></div>      </div>
    </div>
<div class="site-footer"><div class="site-width"><div class="footer-top"><div class="col-left sitemap"><div class="column"><h3 class="column-header">Overview</h3><ul><li><a href="http://freemarker.org/index.html">What is FreeMarker?</a></li><li><a href="http://freemarker.org/freemarkerdownload.html">Download</a></li><li><a href="app_versions.html">Version history</a></li><li><a href="http://freemarker.org/history.html">About us</a></li><li><a itemprop="license" href="app_license.html">License</a></li></ul></div><div class="column"><h3 class="column-header">Handy stuff</h3><ul><li><a href="http://freemarker-online.kenshoo.com/">Try template online</a></li><li><a href="dgui_template_exp.html#exp_cheatsheet">Expressions cheatsheet</a></li><li><a href="ref_directive_alphaidx.html">#directives</a></li><li><a href="ref_builtins_alphaidx.html">?built_ins</a></li><li><a href="ref_specvar.html">.special_vars</a></li></ul></div><div class="column"><h3 class="column-header">Community</h3><ul><li><a href="https://github.com/nanlei/freemarker/tree/manual-zh-2.3-gae/src/manual">Chinese Manual on Github</a></li><li><a href="https://github.com/freemarker/freemarker">FreeMarker on Github</a></li><li><a href="https://twitter.com/freemarker">Follow us on Twitter</a></li><li><a href="https://sourceforge.net/p/freemarker/bugs/new/">Report a bug</a></li><li><a href="http://stackoverflow.com/questions/ask?tags=freemarker">Ask a question</a></li><li><a href="http://freemarker.org/mailing-lists.html">Mailing lists</a></li></ul></div></div><div class="col-right"><ul class="social-icons"><li><a class="github" href="https://github.com/freemarker/freemarker">Github</a></li><li><a class="twitter" href="https://twitter.com/freemarker">Twitter</a></li><li><a class="stack-overflow" href="http://stackoverflow.com/questions/ask?tags=freemarker">Stack Overflow</a></li></ul><a class="xxe" href="http://www.xmlmind.com/xmleditor/" rel="nofollow" title="Edited with XMLMind XML Editor"><span>Edited with XMLMind XML Editor</span></a></div></div><div class="footer-bottom"><p><span class="generated-for-product">Generated for: Freemarker 2.3.23</span><span class="last-updated"> Last generated:
<time itemprop="dateModified" datetime="2015-09-18T14:38:51Z" title="Friday, September 18, 2015 2:38:51 PM GMT">2015-09-18 14:38:51 GMT</time></span></p> <p class="copyright">
© <span itemprop="copyrightYear">1999</span>–2015
<a itemtype="http://schema.org/Organization" itemprop="copyrightHolder" href="http://freemarker.org">The FreeMarker Project</a>. All rights reserved. </p>
</div></div></div></body>
</html>
